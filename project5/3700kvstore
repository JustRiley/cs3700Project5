#!/usr/bin/env python

import sys, socket, select, time, json, random
from random import randint
from collections import OrderedDict

class Server:
	term = 0
	state = 'follower'
	# Your ID number
	id = sys.argv[1]
	# The ID numbers of all the other replicas
	replica_ids = sys.argv[2:]
	leader_id = None
	last_received_rpc = time.time()
	# timeout length for this server (between 150 and 300 ms)
	timeout_length = randint(350, 500)
	# who we voted for, map of term to who we voted for
	voted_for = {}
	# number of votes we received
	election_votes = 1
	# as leader, last time we sent an rpc time
	last_sent_rpc = time.time()
	# timeout length as leader
	rpc_timeout_length = 75
	# our transaction log mapping MID to array [key, value, dst, term]
	transaction_log = OrderedDict()
	# our key value store of committed transactions
	kv_store = OrderedDict()
	# dict mapping MID to array of unique votes
	transaction_votes = {}
	# dict mapping MID to last sent time
	replica_timeout = {}
	# dict mapping MID to term that it was added
	transaction_term = {}
	# the term of our latest commit
	commit_index = -1
	# current log index
	current_log_index = -1
	# current log term
	current_log_term = 0
	# map of replica id to nextindex for that replica
	next_index_map = {}
	buffered_packets = []
	# for debugging purposes
	message_count = 0
	active_replica_ids = {}
	# requests already processed, map MID to response message
	processed_requests = {}
	
	sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
        sock.connect(id)
	
	#enter election period
	def election(self):
		print "{0} becomes a candidate".format(self.id)
		self.term += 1
		self.state = 'candidate'
		self.election_votes = 1
		msg = {'src': self.id, 'dst': 'FFFF', 'term': self.term, 'log_term': self.current_log_term, 'log_index': self.current_log_index, 'leader': 'FFFF', 'type': 'requestvote_rpc'}
                for id in self.replica_ids:
                        msg['dst'] = id
                        self.sock.send(json.dumps(msg))
		self.last_received_rpc = time.time()

	# enter election if we have hit our timeout
	def check_for_timeout(self):
		clock = time.time()
		time_diff = (clock - self.last_received_rpc) * 1000
		if time_diff > self.timeout_length:
			self.election()	

	# resend appenentries_rpc if any replica has timed out
	def check_for_replica_timeout(self):
		clock = time.time()
		for id in self.replica_ids:
			# resend appendentries rpc if we hit timeout. Reset time in our transaction_timeout dict
			if (clock - self.replica_timeout[id]) * 1000 > self.rpc_timeout_length:
				#print "resent transaction msg for {0}".format(id)
				msg = {'src': self.id, 'dst': id, 'leader': self.leader_id, 'term': self.term, 'type': 'leader_rpc','blank': True, 'leader_commit': self.commit_index}
				self.send_rpc(msg)

	# set all of the indexes for our replicas in our next_index_map
	def set_replica_indexes_and_timeouts(self):
		self.next_index_map = {}
		for id in self.replica_ids:
			self.next_index_map[id] = len(self.transaction_log.keys()) - 1
			self.replica_timeout[id] = time.time()
			self.active_replica_ids[id] = 0

	# send append_entry rpc to the replica 
	def send_rpc(self, msg):
		self.replica_timeout[msg['dst']] = time.time()
                prev_log_index = self.next_index_map[msg['dst']]
                #print prev_log_index
                msg['prev_log_index'] = prev_log_index
                # take into account first message
                if len(self.transaction_log.keys()) == 0:
			msg['prev_log_term'] = self.term
			msg['entry_term'] = self.term
		# if send blank leader rpc if 
		elif prev_log_index >= len(self.transaction_log.keys()) - 1:
			msg['blank'] = True
                else:
			#print "prev log index {0} with trasaction log size {1}".format(prev_log_index, len(self.transaction_log.keys()))
			# send term at prev log index
                        key_at_index = self.transaction_log.keys()[prev_log_index]
                        msg['prev_log_term'] = self.transaction_log[key_at_index][3]
			next_key_at_index = self.transaction_log.keys()[prev_log_index + 1]
                        msg['key'] = self.transaction_log[next_key_at_index][0]
                        msg['value'] = self.transaction_log[next_key_at_index][1]
			msg['recipient'] = self.transaction_log[next_key_at_index][2]
			msg['entry_term'] = self.transaction_log[next_key_at_index][3]
			msg['MID'] = next_key_at_index	
			msg['blank'] = False 
                self.sock.send(json.dumps(msg))

	# commit all transactions up to index
	def append_commits(self, commit_index):
		# if incoming commit index is greater than ours, then append commits up to index
		if commit_index > self.commit_index:
			while self.commit_index < commit_index:
				self.commit_index += 1
				key_at_index = self.transaction_log.keys()[self.commit_index]
				# append mid to our processed requests
				client_msg = {'src': self.id, 'dst': self.transaction_log[key_at_index][2], 'leader': self.leader_id, 'type': 'ok', 'MID': key_at_index}
				self.processed_requests[key_at_index] = client_msg
				# append entry to our kv_store
				self.kv_store[self.transaction_log[key_at_index][0]] = self.transaction_log[key_at_index][1]

	# send redirect response to client for buffered packets
	def redirect_buffered_packets(self):
		for packet in self.buffered_packets:
			packet['leader'] = self.leader_id
			self.sock.send(json.dumps(packet))

	# process buffered packets if we became leader
	def process_buffered_packets(self):
		for packet in self.buffered_packets:
			if packet['type'] == 'get':
				# if requested key is in our key value store, return the value
                                if msg['key'] in self.kv_store.keys():
                                	response = {'src': self.id, 'dst': packet['dst'], 'leader': self.leader_id, 'type': 'ok', 'MID': packet['MID'], 'value': self.kv_store[packet['key']]}
                                        self.sock.send(json.dumps(response))
                                # send blank message if key ws never put in our key value store
                                else:
                   	        	response = {'src': self.id, 'dst': packet['dst'], 'leader': self.leader_id, 'type': 'ok', 'MID': packet['MID'], 'value': ''}
                                	self.sock.send(json.dumps(response))
			elif packet['type'] == 'put':
				response = {'src': self.id, 'dst': 'FFFF', 'leader': self.leader_id, 'term': self.term, 'type': 'leader_rpc', 'key': packet['key'],
						'value': packet['value'], 'blank': False, 'prev_log_index': self.current_log_index, 'prev_log_term': self.current_log_term,
				 		'leader_commit': self.commit_index, 'MID': packet['MID'], 'recipient': packet['recipient']}
				self.sock.send(json.dumps(response))

	def receive(self):
		while True:
			if self.state == 'leader':
				self.check_for_replica_timeout()
			else:
				self.check_for_timeout()
			ready = select.select([self.sock], [], [], 0)[0]
	
			if self.sock in ready:
				msg_raw = self.sock.recv(32768)
		
				if len(msg_raw) == 0: continue
				msg = json.loads(msg_raw)
		
				# If we receive get or put, make sure the dst is our id
				if msg['type'] in ['get', 'put'] and msg['dst'] == self.id:
					# if I am follower, want to redirect message
					if self.state == 'follower':		
						# check to make sure we know who the leader is
						if self.leader_id:
							msg = {'src': self.id, 'dst': msg['src'], 'leader': self.leader_id, 'type': 'redirect', 'MID': msg['MID']}
							self.sock.send(json.dumps(msg))
						# initial term, send redirect with leader as multicast
						elif self.term == 0:
							msg = {'src': self.id, 'dst': msg['src'], 'leader': 'FFFF', 'type': 'redirect', 'MID': msg['MID']}
                                                        self.sock.send(json.dumps(msg))
						# in election, add to buffered packets
						else:
                                                	if msg['type'] == 'get':
                                                        	response = {'src': self.id, 'dst': msg['src'], 'leader': 'FFFF', 'type': 'redirect', 'MID': msg['MID'], 'key': msg['key']}
                                                        	self.buffered_packets.append(response)
                                                	elif msg['type'] == 'put':
                                                        	response = {'src': self.id, 'dst': msg['src'], 'leader': 'FFFF', 'type': 'redirect', 'MID': msg['MID'], 'key': msg['key'],
                                                                        'value': msg['value'], 'recipient': msg['src']}
                                                        	self.buffered_packets.append(response)

					# If i am a leader, commit transaction and send rpc to followers
					elif self.state == 'leader':
						# check if we have already processed this message
						if msg['MID'] in self.processed_requests.keys():
							self.sock.send(json.dumps(self.processed_requests[msg['MID']]))
						# If msg is a get, return value to client
						elif msg['type'] == 'get':
							#print "leader received a get {0}".format(msg)
							# if requested key is in our key value store, return the value
							if msg['key'] in self.kv_store.keys():
								response = {'src': self.id, 'dst': msg['src'], 'leader': self.leader_id, 'type': 'ok', 'MID': msg['MID'], 'value': self.kv_store[msg['key']]}
								#self.message_count += 1
								#print "leader send get to client {0}".format(self.message_count)
								self.sock.send(json.dumps(response))
							# send blank message if key ws never put in our key value store
							else:
								response = {'src': self.id, 'dst': msg['src'], 'leader': self.leader_id, 'type': 'ok', 'MID': msg['MID'], 'value': ''}
                                                                self.sock.send(json.dumps(response))
							# add this request to processed_requests
							self.processed_requests[msg['MID']] = response
						# if msg is a put, enter entry into our transaction log and send rpc appendentries to replicas
						elif msg['type'] == 'put':
							#print "leader received a put {0}".format(msg)
							response = {'src': self.id, 'dst': 'FFFF', 'leader': self.leader_id, 'term': self.term, 'type': 'leader_rpc', 
									'key': msg['key'], 'value': msg['value'], 'blank': False, 'prev_log_index': self.current_log_index, 
									'prev_log_term': self.current_log_term, 'leader_commit': self.commit_index, 'MID': msg['MID'], 'recipient': msg['src']}
							self.transaction_log[msg['MID']] = [msg['key'], msg['value'], msg['src'], self.term]
							self.transaction_votes[msg['MID']] = [self.id]
							self.current_log_index += 1
							self.current_log_term = self.term

					# if we are a candidate, buffer packet
					elif self.state == 'candidate':
						#print "candidate {0} sent a fail".format(self.id)
						if msg['type'] == 'get':
							response = {'src': self.id, 'dst': msg['src'], 'leader': 'FFFF', 'type': 'redirect', 'MID': msg['MID'], 'key': msg['key']}
							self.buffered_packets.append(response)
						elif msg['type'] == 'put':
							response = {'src': self.id, 'dst': msg['src'], 'leader': 'FFFF', 'type': 'redirect', 'MID': msg['MID'], 'key': msg['key'],
									'value': msg['value'], 'recipient': msg['src']}
							self.buffered_packets.append(response)

				# Handle noop messages. This may be removed from your final implementation
				elif msg['type'] == 'leader_rpc':
					print "{0} received a leader_rpc {1}".format(self.id, msg)
					if self.state == 'follower':
						self.last_received_rpc = time.time()
					# revert to follower if we are candidate and we receive a leader rpc (leader comes back up)
                                        # make sure leader rpc we receive is at least our term
                                        if self.state == 'candidate' and self.term <= msg['term']:
						self.last_received_rpc = time.time()
                                                self.state = 'follower'
                                                self.election_votes = 1
						self.leader_id = msg['leader']
						self.term = msg['term']
						# send redirect to new leader for our buffered packets
						self.redirect_buffered_packets()
						# clear our buffered packets
						self.buffered_packets = []
						# send requestvote to leader to make it aware of our presence
						#response = {'src': self.id, 'dst': self.leader_id, 'term': self.term, 'log_term': self.current_log_term, 'log_index': self.current_log_index, 'leader': self.leader_id, 'type': 'requestvote_rpc'}
                                                #self.sock.send(json.dumps(response))
						print "{0} candidate reverted to follower and set leader_id to {1}".format(self.id, self.leader_id)
					elif self.state == 'follower' and self.leader_id != msg['leader'] and self.term <= msg['term']:
						self.leader_id = msg['leader']
						self.term = msg['term']
						# redirect our buffered packets
						self.redirect_buffered_packets()
						# clear our buffered packets
						self.buffered_packets = []
						print "{0} set leader_id to {1} and term to {2}".format(self.id, self.leader_id, self.term)
					# set term to leader's term if ours is lower
					elif self.state == 'leader' and self.term < msg['term']:
						self.term = msg['term']
						self.state = 'follower'
						self.election_votes = 1
						self.leader_id = msg['leader']
						print "{0} reverted back to follower from leader and set leader_id to {1}".format(self.id, self.leader_id)
					# if we receive appendentries rpc, add to our transaction log and send confirmation to leader
					if self.state == 'follower' and not msg['blank']:
						# reply false if leader term is less than our term
						if msg['term'] < self.term:
							response =  {'src': self.id, 'dst': self.leader_id, 'term': self.term, 'leader': self.leader_id, 'type': 'ack_rpc', 'key': msg['key'], 'value': msg['value'], 'MID': msg['MID'], 'success': False}
							self.sock.send(json.dumps(response))
						# accept blindly if our transaction log is empty
						#elif len(self.transaction_log.keys()) == 0:
						# trying different initial check
						elif msg['prev_log_index']  == -1:
							print "hit initial block {0}".format(self.id)
							response =  {'src': self.id, 'dst': self.leader_id, 'term': self.term, 'leader': self.leader_id, 'type': 'ack_rpc', 'key': msg['key'], 'value': msg['value'], 'MID': msg['MID'], 'success': True}
                                                        self.transaction_log[msg['MID']] = [msg['key'], msg['value'], msg['recipient'], msg['entry_term']]
                                                        self.current_log_index = msg['prev_log_index'] + 1
                                                        self.current_log_term = msg['entry_term']
							self.sock.send(json.dumps(response))
							new_commit_index = min(msg['leader_commit'], msg['prev_log_index'])
                                                	self.append_commits(new_commit_index)	
							
						# reply false if our log doesnt contain same entry or term
						#TODO this is dumb
						elif msg['prev_log_index'] <= len(self.transaction_log.keys()) - 1:
							#if self.transaction_log.keys().index(msg['MID']) != msg['prev_log_index']:
							#	print "sent fail message 2"
							#	response =  {'src': self.id, 'dst': self.leader_id, 'term': self.term, 'leader': self.leader_id, 'type': 'ack_rpc', 'key': msg['key'], 'value': msg['value'], 'MID': msg['MID'], 'success': False}
							key_at_index = self.transaction_log.keys()[msg['prev_log_index']]
							if self.transaction_log[key_at_index][3] != msg['prev_log_term']:
								#print "{0} hit different prev log term for index {1} our term {2} vs their term {3}".format(self.id, msg['prev_log_index'],self.transaction_log[key_at_index][3], msg['prev_log_term'])
								self.current_log_index = msg['prev_log_index'] - 1
								# only change current log term if our log index isnt at beginning
								if self.current_log_index > -1:
									self.current_log_term = self.transaction_log.keys()[self.current_log_index][3]
								# delete all entries after index
								delete_index = self.transaction_log.keys().index(key_at_index)
								self.transaction_log.keys()[:delete_index]
								print "transaction log length after delete {0}".format(len(self.transaction_log.keys()) - 1)
								response =  {'src': self.id, 'dst': self.leader_id, 'term': self.term, 'leader': self.leader_id, 'type': 'ack_rpc', 'key': msg['key'], 'value': msg['value'], 'MID': msg['MID'], 'success': False}
                                                        
							else:
								
								#print "{0} sent success for {1} with term {2}".format(self.id, msg['prev_log_index'], msg['term'])
								response =  {'src': self.id, 'dst': self.leader_id, 'term': self.term, 'leader': self.leader_id, 'type': 'ack_rpc', 'key': msg['key'], 'value': msg['value'], 'MID': msg['MID'], 'success': True}
								self.transaction_log[msg['MID']] = [msg['key'], msg['value'], msg['recipient'], msg['entry_term']]
								#print "after insert, transaction log length is now {0}".format(len(self.transaction_log.keys()))
								self.current_log_index = msg['prev_log_index'] + 1
								self.current_log_term = msg['entry_term']
								new_commit_index = min(msg['leader_commit'], msg['prev_log_index'])
                                                		self.append_commits(new_commit_index)

							#self.message_count += 1
							#print "{1} sent ack to leader total: {0}".format(self.message_count, self.id)
							self.sock.send(json.dumps(response))
						else:
							#print "sent fail message 5 msg: {0}".format(msg)
							#print "{0} prev log index at {1} with our transaction log -1 at {2}".format(self.id, msg['prev_log_index'], len(self.transaction_log.keys()) - 1) 
							response =  {'src': self.id, 'dst': self.leader_id, 'term': self.term, 'leader': self.leader_id, 'type': 'ack_rpc', 'key': msg['key'], 'value': msg['value'], 'MID': msg['MID'], 'success': False}
							#self.message_count += 1
							#print"send ack to leader total: {0}".format(self.message_count)
							self.sock.send(json.dumps(response))


				# received a request for a vote rpc
				elif msg['type'] == 'requestvote_rpc':
					if self.term < msg['term']:
						self.term = msg['term']
						self.state = 'follower'
					print "{0} received a vote request state: {1}".format(self.id, self.state)
					if self.state == 'follower':
					# make sure we are a follower and we haven't yet voted in this term
						if msg['term'] not in self.voted_for.keys():
							# if our commit term is lower, then vote
							if self.current_log_term < msg['log_term']:
								print "{0} voted for {1}".format(self.id, msg['src'])
								response = {'src': self.id, 'dst': msg['src'], 'leader': 'FFFF', 'type': 'vote_rpc'}
								self.sock.send(json.dumps(response))
								# reset our last received rpc time
								#self.last_received_rpc = time.time()
								self.voted_for[msg['term']]  = msg['src']
								self.leader_id = None
							# if commit terms same, compare log index
							elif self.current_log_term == msg['log_term'] and self.current_log_index <= msg['log_index']:
								print "{0} voted for {1}".format(self.id, msg['src'])
								response = {'src': self.id, 'dst': msg['src'], 'leader': 'FFFF', 'type': 'vote_rpc'}
                                                        	self.sock.send(json.dumps(response))
                                                        	# reset our last received rpc time
                                                        	#self.last_received_rpc = time.time()
                                                        	self.voted_for[msg['term']] = msg['src']
								self.leader_id = None
					elif self.state == 'leader':
					#	 reset the active replicas
						if self.active_replica_ids[msg['src']] >= 10:
							for id in self.active_replica_ids.keys():
								self.active_replica_ids[id] = 0

					# switch our vote if their log is more up to date than ours
					elif self.state == 'candidate':
						# if our commit term is lower, then vote
                                                if self.current_log_term < msg['log_term']:
                                                	print "{0} candidate voted for {1}".format(self.id, msg['src'])
                                                        self.state = 'follower'
							self.election_votes = 1
							response = {'src': self.id, 'dst': msg['src'], 'leader': 'FFFF', 'type': 'vote_rpc'}
                                                        self.sock.send(json.dumps(response))
                                                        # reset our last received rpc time
                                                        self.last_received_rpc = time.time()
                                                        self.voted_for[msg['term']]  = msg['src']
                                                        self.leader_id = None
                                                # if commit terms same, compare log index
                                                elif self.current_log_term == msg['log_term'] and self.current_log_index <= msg['log_index']:
                                                        print "{0} candidate voted for {1}".format(self.id, msg['src'])
                                                        self.state = 'follower'
							self.election_votes = 1
							response = {'src': self.id, 'dst': msg['src'], 'leader': 'FFFF', 'type': 'vote_rpc'}
                                                        self.sock.send(json.dumps(response))
                                                        # reset our last received rpc time
                                                        self.last_received_rpc = time.time()
                                                        self.voted_for[msg['term']] = msg['src']
                                                        self.leader_id = None
	
				# received a vote rpc
				elif msg['type'] == 'vote_rpc' and self.state == 'candidate':
					print "{0} received a vote".format(self.id)
					self.election_votes += 1
					# become leader if we receive majority of votes
					if self.election_votes >= len(self.replica_ids) // 2 + 1:
						print "{0} became leader with log index a {1}".format(self.id, len(self.transaction_log.keys()) - 1)
						self.state = 'leader'
						self.leader_id = self.id
						self.election_votes = 1
						# initialize our replicas' prev_log_index
						self.set_replica_indexes_and_timeouts()
						# process our buffered packets
						self.process_buffered_packets()
						# clear out buffered packets
						self.buffered_packets = []
						# reset our transaction timeout and votes
						self.transaction_votes = {}
						# immediately send empty rpc message
						msg = {'src': self.id, 'dst': 'FFFF', 'leader': self.leader_id, 'term': self.term, 'type': 'leader_rpc','blank': True, 'leader_commit': self.commit_index}
						for id in self.replica_ids:
							msg['dst'] = id
							self.sock.send(json.dumps(msg))
						self.last_sent_rpc = time.time()

				# leader received ack for transaction
				elif msg['type'] == 'ack_rpc':
					self.active_replica_ids[msg['src']] = 0
					if msg['success']:
						print "received a success for {0} by {1}".format(msg['MID'], msg['src'])
						self.next_index_map[msg['src']] += 1
						if msg['MID'] in self.transaction_votes.keys():
							# increment number of votes for this key
							if msg['src']  not in self.transaction_votes[msg['MID']]:
								self.transaction_votes[msg['MID']].append(msg['src'])
							# check to see if we reached quorum
							if len(self.transaction_votes[msg['MID']]) >= len(self.replica_ids) // 2 + 1:
								# delete entry from our timeout and votes dicts
								del self.transaction_votes[msg['MID']]
								# commit our transaction
								#self.kv_store[self.transaction_log[msg['MID']][0]] = self.transaction_log[msg['MID']][1]
								# update our commit index
								new_commit_index = self.transaction_log.keys().index(msg['MID'])
								#self.message_count += 5
								#print "multicast because commit total: {0}".format(self.message_count)
								self.append_commits(new_commit_index)
								# send ok to client
								client_msg = {'src': self.id, 'dst': self.transaction_log[msg['MID']][2], 'leader': self.leader_id, 'type': 'ok', 'MID': msg['MID']}
								# add MID to our processed_requests
								self.processed_requests[msg['MID']] = client_msg
								self.sock.send(json.dumps(client_msg))
					# if we got a fail from replica
					else:
						print "received a fail for {0} by {1}".format(msg['MID'], msg['src'])
						if self.term < msg['term']:
							self.term = msg['term']
							self.state = 'follower'
						# decrement our next index
						self.next_index_map[msg['src']] -= 1
					# send next packet
                                        response = {'src': self.id, 'dst': msg['src'], 'leader': self.leader_id, 'term': self.term, 'type': 'leader_rpc','blank': True, 'leader_commit': self.commit_index}
                                        self.send_rpc(response)
if __name__ == '__main__':
	server = Server()
	server.receive()

#!/usr/bin/env python

import sys, socket, select, time, json, random
from random import randint


class Server:
	term = 1
	state = 'follower'
	# Your ID number
	id = sys.argv[1]
	# The ID numbers of all the other replicas
	replica_ids = sys.argv[2:]
	leader_id = None
	last_received_rpc = time.time()
	# timeout length for this server (between 150 and 300 ms)
	timeout_length = randint(150, 300)
	# the time when we started our election
	election_start_time = time.time()
	# flag to check if we voted already
	voted = False
	# number of votes we received
	election_votes = 1
	# as leader, last time we sent an rpc time
	last_sent_rpc = time.time()
	# timeout length as leader
	rpc_timeout_length = 100

	#enter election period
	def election(self):
		self.state = 'candidate'
		msg = {'src': self.id, 'dst': 'FFFF', 'type': 'requestvote_rpc'}
		sock.send(json.dumps(msg))
		self.election_start_time = time.time()

	# enter election if we have hit our timeout
	def check_for_timeout(self):
		clock = time.time()
		if (clock - self.last_received_rpc) * 1000 > self.timeout_length:
			self.election()			

	# resend rpc if we hit our timeout
	def check_for_rpc_timeout(self):
		clock = time.time()
		if (clock - self.last_sent_rpc) * 1000 > self.rpc_timeout_length:
			msg = {'src': self.id, 'dst': 'FFFF', 'type': 'leader_rpc', 'term': self.term}
			self.send(json.dumps(msg))
		self.last_sent_rpc = time.time()

	def receive(self):
		# Connect to the network. All messages to/from other replicas and clients will
		# occur over this socket
		sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
		sock.connect(self.id)

		last = 0

		while True:
			if self.leader_id:
				self.check_for_timeout()
			if self.state == 'candidate':
				self.check_for_timeout()
			if self.state == 'leader':
				self.check_for_rpc_timeout()
			ready = select.select([sock], [], [], 0.1)[0]
	
			if sock in ready:
				msg_raw = sock.recv(32768)
		
				if len(msg_raw) == 0: continue
				msg = json.loads(msg_raw)
		
				# If we receive get or put, make sure the dst is our id
				if msg['type'] in ['get', 'put'] and msg['dst'] == self.id:
					# if I am follower, want to redirect message
					if self.state == 'follower':		
						# check to make sure we know who the leader is
						if self.leader_id:
							msg = {'src': self.id, 'dst': msg['src'], 'leader': self.leader_id, 'type': 'redirect', 'MID': msg['MID']}
							sock.send(json.dumps(msg))
						else:
							msg = {'src': self.id, 'dst': msg['src'], 'leader': 'FFFF', 'type': 'redirect', 'MID': msg['MID']}
                                                        sock.send(json.dumps(msg))
		
				# Handle noop messages. This may be removed from your final implementation
				elif msg['type'] == 'leader_rpc':
					# reset our last received rpc time
					self.last_received_rpc = time.time()
					if self.leader_id != msg['src']:
						self.leader_id = msg['src']
						self.voted = False
					# set term to leader's term if ours is lower
					if self.term < msg['term']:
						self.term = msg['term']
						# revert to follower if we are leader and we receive leader rpc with term lower than ours
						if self.state == 'leader'
							self.state == 'follower'
					# revert to follower if we are candidate and we receive a leader rpc (leader comes back up)
					if self.state == 'candidate':
						self.state = 'follower'
				# received a request for a vote rpc
				elif msg['type'] == 'requestvote_rpc':
					# make sure we dont vote twice and we arent a candidate ourself
					if not self.voted and self.state != 'candidate':
						msg = {'src': self.id, 'dst': msg['src'], 'type': 'vote_rpc'}
						sock.send(json.dumps(msg))
						self.voted = True
				# received a vote rpc
				elif msg['type'] == 'vote_rpc':
					self.election_votes += 1
					# become leader if we receive majority of votes
					if self.election_votes >= replica_ids.size() // 2 + 1:
						self.state = 'leader'
						self.election_votes = 1
						self.term += 1

if __name__ == '__main__':
	server = Server()
	server.receive()

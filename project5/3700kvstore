#!/usr/bin/env python

import sys, socket, select, time, json, random
from enum import Enum
from random import randint

state = enum('leader', 'follower', 'candidate')

class Server:
	term = 1
	state = 'follower'
	# Your ID number
	id = sys.argv[1]
	# The ID numbers of all the other replicas
	replica_ids = sys.argv[2:]
	leader_id = None
	last_received_rpc = time.time()
	# timeout length for this server (between 150 and 300 ms)
	timeout_length = randint(150, 300)

	#enter election period
	def election(self):
		#TODO

	# enter election if we have hit our timeout
	def check_for_timeout(self):
		clock = time.time()
		if (clock - self.last_received_rpc) * 1000 > self.timeout_length:
			self.election()			

	def receive(self):
		# Connect to the network. All messages to/from other replicas and clients will
		# occur over this socket
		sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
		sock.connect(my_id)

		last = 0

		while True:
			self.check_for_timeout()
			ready = select.select([sock], [], [], 0.1)[0]
	
			if sock in ready:
				msg_raw = sock.recv(32768)
		
				if len(msg_raw) == 0: continue
				msg = json.loads(msg_raw)
		
				# If we receive get or put, make sure the dst is our id
				if msg['type'] in ['get', 'put'] and msg['dst'] == self.id:
					# if I am follower, want to redirect message
					if self.state == 'follower':		
						# check to make sure we know who the leader is
						if leader_id:
							msg = {'src': self.id, 'dst': msg['src'], 'leader': leader_id, 'type': 'redirect', 'MID': msg['MID']}
							sock.send(json.dumps(msg))
		
				# Handle noop messages. This may be removed from your final implementation
				elif msg['type'] == 'noop':
					print '%s received a NOOP from %s' % (msg['dst'], msg['src'])
		
